#!/usr/bin/env pwsh
# Free-Tier Multi-Agent Orchestrator
# Combines generous free tiers with local-first tools for unlimited usage

param(
    [Parameter(Mandatory)]
    [ValidateSet("init", "start-lane", "submit", "integrate", "status", "quota-check", "setup-local", "rotate-service", "analyze-task", "start-agentic", "cost-report", "optimize-task")]
    [string]$Command,

    [string]$Lane,
    [string]$Message,
    [string]$ConfigPath = ".ai/framework-config.json",
    [switch]$Force,
    [switch]$DryRun
)

# Load configuration
function Get-FrameworkConfig {
    if (-not (Test-Path $ConfigPath)) {
        Write-Error "Framework config not found at $ConfigPath. Run 'init' first."
        exit 1
    }
    return Get-Content $ConfigPath | ConvertFrom-Json
}

# Quota management functions
function Get-QuotaTracker {
    $quotaPath = ".ai/quota-tracker.json"
    if (-not (Test-Path $quotaPath)) {
        $defaultQuota = @{
            lastReset = (Get-Date).ToString("yyyy-MM-dd")
            services = @{}
        }
        $defaultQuota | ConvertTo-Json | Set-Content $quotaPath
    }
    return Get-Content $quotaPath | ConvertFrom-Json
}

function Update-QuotaUsage {
    param(
        [string]$Service,
        [int]$UsageCount = 1
    )

    $tracker = Get-QuotaTracker
    $config = Get-FrameworkConfig

    # Reset daily quotas if needed
    $today = (Get-Date).ToString("yyyy-MM-dd")
    if ($tracker.lastReset -ne $today) {
        foreach ($serviceName in $config.quotaManagement.services.PSObject.Properties.Name) {
            if ($config.quotaManagement.services.$serviceName.resetTime -eq "00:00 UTC") {
                $tracker.services.$serviceName = 0
            }
        }
        $tracker.lastReset = $today
    }

    # Update usage
    if (-not $tracker.services.$Service) {
        $tracker.services.$Service = 0
    }
    $tracker.services.$Service += $UsageCount

    # Save tracker
    $tracker | ConvertTo-Json | Set-Content ".ai/quota-tracker.json"

    Write-Host "üìä Updated quota usage for $Service: $($tracker.services.$Service)" -ForegroundColor Cyan
}

function Get-BestAvailableService {
    param([string]$UseCase = "coding")

    $config = Get-FrameworkConfig
    $tracker = Get-QuotaTracker

    # Sort services by priority
    $availableServices = @()

    foreach ($serviceName in $config.quotaManagement.services.PSObject.Properties.Name) {
        $service = $config.quotaManagement.services.$serviceName
        $currentUsage = if ($tracker.services.$serviceName) { $tracker.services.$serviceName } else { 0 }

        $isAvailable = $true
        if ($service.dailyLimit -ne "unlimited") {
            $usagePercent = $currentUsage / $service.dailyLimit
            if ($usagePercent -ge 0.95) {
                $isAvailable = $false
            }
        }

        if ($isAvailable) {
            $availableServices += @{
                name = $serviceName
                priority = $service.priority
                usagePercent = if ($service.dailyLimit -eq "unlimited") { 0 } else { $currentUsage / $service.dailyLimit }
            }
        }
    }

    if ($availableServices.Count -eq 0) {
        Write-Host "‚ö†Ô∏è  All quotas exceeded, falling back to local models" -ForegroundColor Yellow
        return "local"
    }

    $bestService = $availableServices | Sort-Object priority | Select-Object -First 1
    Write-Host "üéØ Selected service: $($bestService.name) (Usage: $([math]::Round($bestService.usagePercent * 100, 1))%)" -ForegroundColor Green

    return $bestService.name
}

# Local model management
function Initialize-LocalModels {
    $config = Get-FrameworkConfig

    Write-Host "üîß Setting up local models..." -ForegroundColor Blue

    # Check if Ollama is installed
    try {
        $ollamaVersion = ollama --version
        Write-Host "‚úÖ Ollama is installed: $ollamaVersion" -ForegroundColor Green
    }
    catch {
        Write-Host "‚ùå Ollama not found. Installing..." -ForegroundColor Red
        if ($IsWindows) {
            Write-Host "Please install Ollama from https://ollama.ai/download/windows"
        } else {
            Invoke-Expression "curl -fsSL https://ollama.ai/install.sh | sh"
        }
        exit 1
    }

    # Pull required models
    foreach ($modelName in $config.localModels.models.PSObject.Properties.Name) {
        $model = $config.localModels.models.$modelName
        Write-Host "üì• Pulling model: $($model.name)" -ForegroundColor Cyan

        if (-not $DryRun) {
            ollama pull $model.name
        }
    }

    Write-Host "‚úÖ Local models setup complete!" -ForegroundColor Green
}

# Agentic task classification and service selection functions
function Get-TaskComplexity {
    param([string]$TaskDescription)
    $complexKeywords = @("architecture","redesign","refactor large","performance optimization","security audit","database migration","infrastructure overhaul","multi-service","microservices","research","system design","cross-platform","scalability","integration strategy")
    $moderateKeywords = @("feature implementation","API development","integration","test suite","validation logic","configuration management","multi-file refactor","component development","data modeling")
    $simpleKeywords = @("fix bug","typo","format","logging","comment","documentation","variable rename","import cleanup","style fix","small refactor")
    foreach ($keyword in $complexKeywords) {
        if ($TaskDescription -like "*$keyword*") { return "complex" }
    }
    foreach ($keyword in $moderateKeywords) {
        if ($TaskDescription -like "*$keyword*") { return "moderate" }
    }
    return "simple"
}

function Get-OptimalService {
    param(
        [string]$TaskDescription,
        [string]$Complexity = $null,
        [switch]$Force
    )
    if (-not $Complexity) {
        $Complexity = Get-TaskComplexity $TaskDescription
    }
    $config = Get-FrameworkConfig
    $tracker = Get-QuotaTracker
    $recommendedService = $config.taskClassification.$Complexity.recommendedService
    if ($recommendedService -eq "claude_code" -and -not $Force) {
        $currentUsage = $tracker.services.claude_code ?? 0
        $dailyLimit = $config.quotaManagement.services.claude_code.dailyLimit
        $warningThreshold = $config.quotaManagement.services.claude_code.warningThreshold
        $costPerRequest = $config.quotaManagement.services.claude_code.costPerRequest
        $usagePercent = $currentUsage / $dailyLimit
        $estimatedCost = $currentUsage * $costPerRequest
        Write-Host "üí∞ Claude Code Usage Analysis:" -ForegroundColor Yellow
        Write-Host "  Current usage: $currentUsage/$dailyLimit ($([math]::Round($usagePercent * 100, 1))%)" -ForegroundColor Cyan
        Write-Host "  Today's cost: $([math]::Round($estimatedCost, 2))" -ForegroundColor Red
        Write-Host "  Request cost: $costPerRequest" -ForegroundColor Yellow
        if ($usagePercent -gt $warningThreshold) {
            Write-Host "‚ö†Ô∏è  WARNING: High Claude Code usage!" -ForegroundColor Red
            Write-Host "üí° Consider alternatives:" -ForegroundColor Blue
            Write-Host "  - Break task into smaller parts" -ForegroundColor Green
            Write-Host "  - Use Gemini CLI for research phase" -ForegroundColor Green
            Write-Host "  - Use Aider + local models for implementation" -ForegroundColor Green
            $confirm = Read-Host "Continue with Claude Code? (y/N)"
            if ($confirm -ne "y") {
                Write-Host "üîÑ Falling back to cost-optimized alternatives" -ForegroundColor Cyan
                return "aider_local"
            }
        }
        $monthlyProjection = $estimatedCost * 30
        Write-Host "üìä Monthly projection: $([math]::Round($monthlyProjection, 2))" -ForegroundColor Yellow
    }
    return $recommendedService
}

function Start-AgenticWorkflow {
    param(
        [string]$TaskDescription,
        [string]$WorkflowType = "research_plan_code"
    )
    $config = Get-FrameworkConfig
    $workflow = $config.agenticPatterns.$WorkflowType
    if (-not $workflow.enabled) {
        Write-Error "Workflow '$WorkflowType' is not enabled"
        return
    }
    Write-Host "ü§ñ Starting agentic workflow: $WorkflowType" -ForegroundColor Blue
    Write-Host "üìù Task: $TaskDescription" -ForegroundColor Cyan
    foreach ($phase in $workflow.phases) {
        Write-Host "`nüîÑ Phase: $($phase.name)" -ForegroundColor Green
        Write-Host "üõ†Ô∏è  Service: $($phase.service)" -ForegroundColor Cyan
        Write-Host "üí∞ Cost: $($phase.cost)" -ForegroundColor Yellow
        if ($phase.requiresApproval) {
            $confirm = Read-Host "Proceed with $($phase.service)? (y/N)"
            if ($confirm -ne "y") {
                Write-Host "‚è≠Ô∏è  Skipping phase" -ForegroundColor Yellow
                continue
            }
        }
        switch ($phase.service) {
            "gemini_cli" {
                Write-Host "üîç Research phase - using Gemini CLI" -ForegroundColor Green
                # Add Gemini CLI execution logic here
            }
            "claude_code" {
                Write-Host "üèóÔ∏è  Planning phase - using Claude Code" -ForegroundColor Green
                Update-QuotaUsage "claude_code"
                # Add Claude Code execution logic here
            }
            "aider_local" {
                Write-Host "‚ö° Implementation phase - using Aider + Local" -ForegroundColor Green
                # Add Aider execution logic here
            }
        }
    }
    Write-Host "`n‚úÖ Agentic workflow completed!" -ForegroundColor Green
}

# Git worktree management
function Initialize-Lanes {
    $config = Get-FrameworkConfig

    Write-Host "üîß Initializing Git worktrees and lanes..." -ForegroundColor Blue

    # Ensure we're in a Git repository
    if (-not (Test-Path ".git")) {
        git init
        git add .
        git commit -m "Initial commit"
    }

    # Create integration branch
    git checkout -b integrate 2>$null
    git checkout main 2>$null

    foreach ($laneName in $config.lanes.PSObject.Properties.Name) {
        $lane = $config.lanes.$laneName
        Write-Host "üõ§Ô∏è  Setting up lane: $laneName" -ForegroundColor Cyan

        if (-not $DryRun) {
            # Create worktree directory
            $worktreePath = $lane.worktreePath
            if (-not (Test-Path $worktreePath)) {
                New-Item -ItemType Directory -Path $worktreePath -Force | Out-Null
            }

            # Create branch and worktree
            git worktree add $worktreePath $lane.branch 2>$null
            if ($LASTEXITCODE -ne 0) {
                git branch $lane.branch
                git worktree add $worktreePath $lane.branch
            }
        }
    }

    Write-Host "‚úÖ Lanes initialized successfully!" -ForegroundColor Green
}

# Lane operation functions
function Start-Lane {
    param([string]$LaneName)

    $config = Get-FrameworkConfig

    if (-not $config.lanes.$LaneName) {
        Write-Error "Lane '$LaneName' not found in configuration"
        return
    }

    $lane = $config.lanes.$LaneName
    $worktreePath = $lane.worktreePath

    Write-Host "üöÄ Starting lane: $LaneName" -ForegroundColor Green
    Write-Host "üìÅ Worktree path: $worktreePath" -ForegroundColor Cyan

    # Generate VS Code command
    $vscodeCommand = "code `"$worktreePath`""
    Write-Host "üíª Open in VS Code:" -ForegroundColor Yellow
    Write-Host $vscodeCommand -ForegroundColor White

    # Show tool configuration
    Write-Host "üîß Available tools:" -ForegroundColor Cyan
    if ($lane.tools.primary) {
        Write-Host "  Primary: $($lane.tools.primary.tool)" -ForegroundColor Green
    }
    if ($lane.tools.fallback) {
        Write-Host "  Fallback: $($lane.tools.fallback.tool)" -ForegroundColor Yellow
    }

    return $vscodeCommand
}

function Submit-Lane {
    param(
        [string]$LaneName,
        [string]$CommitMessage
    )

    $config = Get-FrameworkConfig
    $lane = $config.lanes.$LaneName

    if (-not $lane) {
        Write-Error "Lane '$LaneName' not found"
        return
    }

    Write-Host "üì§ Submitting lane: $LaneName" -ForegroundColor Blue

    Push-Location $lane.worktreePath
    try {
        # Check allowed patterns
        $changedFiles = git diff --name-only HEAD~1 HEAD
        $allowedFiles = @()
        $rejectedFiles = @()

        foreach ($file in $changedFiles) {
            $allowed = $false
            foreach ($pattern in $lane.allowedPatterns) {
                if ($file -like $pattern) {
                    $allowed = $true
                    break
                }
            }

            if ($lane.excludePatterns) {
                foreach ($pattern in $lane.excludePatterns) {
                    if ($file -like $pattern) {
                        $allowed = $false
                        break
                    }
                }
            }

            if ($allowed) {
                $allowedFiles += $file
            } else {
                $rejectedFiles += $file
            }
        }

        if ($rejectedFiles.Count -gt 0) {
            Write-Warning "‚ùå Rejected files (outside lane scope):"
            $rejectedFiles | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
            return
        }

        # Run pre-commit checks
        if ($lane.preCommit) {
            Write-Host "üîç Running pre-commit checks..." -ForegroundColor Cyan
            foreach ($check in $lane.preCommit) {
                Write-Host "  Running: $check" -ForegroundColor Gray
                if (-not $DryRun) {
                    Invoke-Expression $check
                    if ($LASTEXITCODE -ne 0) {
                        Write-Error "Pre-commit check failed: $check"
                        return
                    }
                }
            }
        }

        # Commit changes
        if (-not $DryRun) {
            git add .
            $fullMessage = "$($lane.commitPrefix) $CommitMessage"
            git commit -m $fullMessage

            if ($config.git.push) {
                git push origin $lane.branch
            }
        }

        Write-Host "‚úÖ Lane submitted successfully!" -ForegroundColor Green
        Write-Host "üìù Files changed: $($allowedFiles.Count)" -ForegroundColor Cyan

    } finally {
        Pop-Location
    }
}

function Invoke-Integration {
    $config = Get-FrameworkConfig

    Write-Host "üîÑ Starting integration process..." -ForegroundColor Blue

    # Switch to integration branch
    git checkout integrate
    git reset --hard main

    # Merge lanes in order
    $integrationOrder = $config.integration.order
    if (-not $integrationOrder) {
        $integrationOrder = $config.lanes.PSObject.Properties.Name
    }

    foreach ($laneName in $integrationOrder) {
        $lane = $config.lanes.$laneName
        Write-Host "üîÄ Merging lane: $laneName" -ForegroundColor Cyan

        if (-not $DryRun) {
            git merge $lane.branch --no-ff -m "Integrate $laneName"
            if ($LASTEXITCODE -ne 0) {
                Write-Error "‚ùå Integration failed at lane: $laneName"
                return
            }
        }
    }

    # Run integration tests
    if ($config.integration.testCommand) {
        Write-Host "üß™ Running integration tests..." -ForegroundColor Cyan
        if (-not $DryRun) {
            Invoke-Expression $config.integration.testCommand
            if ($LASTEXITCODE -ne 0) {
                Write-Error "‚ùå Integration tests failed"
                return
            }
        }
    }

    # Fast-forward main
    if (-not $DryRun) {
        git checkout main
        git merge integrate --ff-only
    }

    Write-Host "‚úÖ Integration completed successfully!" -ForegroundColor Green
}

function Show-Status {
    $config = Get-FrameworkConfig
    $tracker = Get-QuotaTracker

    Write-Host "üìä Framework Status" -ForegroundColor Blue
    Write-Host "==================" -ForegroundColor Blue

    # Quota status
    Write-Host "`nüéØ Service Quotas:" -ForegroundColor Cyan
    foreach ($serviceName in $config.quotaManagement.services.PSObject.Properties.Name) {
        $service = $config.quotaManagement.services.$serviceName
        $currentUsage = if ($tracker.services.$serviceName) { $tracker.services.$serviceName } else { 0 }

        if ($service.dailyLimit -eq "unlimited") {
            $status = "‚úÖ Unlimited"
            $color = "Green"
        } else {
            $usagePercent = ($currentUsage / $service.dailyLimit) * 100
            $color = if ($usagePercent -lt 70) { "Green" } elseif ($usagePercent -lt 90) { "Yellow" } else { "Red" }
            $status = "$currentUsage/$($service.dailyLimit) ($([math]::Round($usagePercent, 1))%)"
        }

        Write-Host "  $serviceName`: $status" -ForegroundColor $color
    }

    # Lane status
    Write-Host "`nüõ§Ô∏è  Lane Status:" -ForegroundColor Cyan
    foreach ($laneName in $config.lanes.PSObject.Properties.Name) {
        $lane = $config.lanes.$laneName
        $branchExists = git branch --list $lane.branch
        $status = if ($branchExists) { "‚úÖ Ready" } else { "‚ùå Not initialized" }
        Write-Host "  $laneName`: $status" -ForegroundColor $(if ($branchExists) { "Green" } else { "Red" })
    }

    # Local models status
    Write-Host "`nü§ñ Local Models:" -ForegroundColor Cyan
    try {
        $installedModels = ollama list | Select-String -Pattern "^[a-zA-Z]" | ForEach-Object { $_.ToString().Split()[0] }
        foreach ($modelName in $config.localModels.models.PSObject.Properties.Name) {
            $model = $config.localModels.models.$modelName
            $isInstalled = $installedModels -contains $model.name
            $status = if ($isInstalled) { "‚úÖ Installed" } else { "‚ùå Missing" }
            Write-Host "  $($model.name)`: $status" -ForegroundColor $(if ($isInstalled) { "Green" } else { "Red" })
        }
    }
    catch {
        Write-Host "  ‚ùå Ollama not available" -ForegroundColor Red
    }
}

# Main command dispatcher
switch ($Command) {
    "init" {
        Write-Host "üöÄ Initializing Free-Tier Framework..." -ForegroundColor Blue
        Initialize-Lanes
        Write-Host "‚úÖ Framework initialized! Run 'setup-local' to configure local models." -ForegroundColor Green
    }

    "setup-local" {
        Initialize-LocalModels
    }

    "start-lane" {
        if (-not $Lane) {
            Write-Error "Lane parameter required. Available lanes: $($(Get-FrameworkConfig).lanes.PSObject.Properties.Name -join ', ')"
            exit 1
        }
        Start-Lane $Lane
    }

    "submit" {
        if (-not $Lane) {
            Write-Error "Lane parameter required"
            exit 1
        }
        if (-not $Message) {
            Write-Error "Message parameter required"
            exit 1
        }
        Submit-Lane $Lane $Message
    }

    "integrate" {
        Invoke-Integration
    }

    "status" {
        Show-Status
    }

    "quota-check" {
        $bestService = Get-BestAvailableService
        Write-Host "üí° Recommended service: $bestService" -ForegroundColor Green
    }

    "rotate-service" {
        $config = Get-FrameworkConfig
        Write-Host "üîÑ Service rotation logic:" -ForegroundColor Blue
        foreach ($rule in $config.serviceRotation.rotationRules) {
            Write-Host "  $($rule.condition) ‚Üí $($rule.action)" -ForegroundColor Cyan
        }
    }

    "analyze-task" {
        if (-not $Message) {
            Write-Error "Message parameter required for task analysis"
            exit 1
        }
        $complexity = Get-TaskComplexity $Message
        $service = Get-OptimalService $Message $complexity
        Write-Host "üéØ Task Analysis Results:" -ForegroundColor Blue
        Write-Host "  Description: $Message" -ForegroundColor Cyan
        Write-Host "  Complexity: $complexity" -ForegroundColor Yellow
        Write-Host "  Recommended Service: $service" -ForegroundColor Green
        if ($service -eq "claude_code") {
            Write-Host "`nüí° Cost Optimization Tips:" -ForegroundColor Blue
            Write-Host "  1. Break complex tasks into phases" -ForegroundColor Green
            Write-Host "  2. Use research-plan-code workflow" -ForegroundColor Green
            Write-Host "  3. Research with Gemini (free) first" -ForegroundColor Green
        }
    }

    "start-agentic" {
        if (-not $Message) {
            Write-Error "Message parameter required for agentic workflow"
            exit 1
        }
        $workflowType = if ($Lane) { $Lane } else { "research_plan_code" }
        Start-AgenticWorkflow $Message $workflowType
    }

    "cost-report" {
        $tracker = Get-QuotaTracker
        $config = Get-FrameworkConfig
        Write-Host "üí∞ Daily Cost Report:" -ForegroundColor Blue
        Write-Host "=====================" -ForegroundColor Blue
        $totalCost = 0
        foreach ($serviceName in $config.quotaManagement.services.PSObject.Properties.Name) {
            $service = $config.quotaManagement.services.$serviceName
            $usage = $tracker.services.$serviceName ?? 0
            if ($service.costPerRequest) {
                $cost = $usage * $service.costPerRequest
                $totalCost += $cost
                Write-Host "  $serviceName`: $usage requests = $([math]::Round($cost, 2))" -ForegroundColor $(if ($cost -gt 1) { "Red" } else { "Green" })
            } else {
                Write-Host "  $serviceName`: $usage requests = $0.00 (free)" -ForegroundColor Green
            }
        }
        Write-Host "`nTotal daily cost: $([math]::Round($totalCost, 2))" -ForegroundColor Yellow
        Write-Host "Monthly projection: $([math]::Round($totalCost * 30, 2))" -ForegroundColor Red
        Write-Host "vs Commercial alternatives: ~$500/month" -ForegroundColor Cyan
        Write-Host "üí∞ Savings: $([math]::Round(500 - ($totalCost * 30), 2))/month" -ForegroundColor Green
    }

    "optimize-task" {
        if (-not $Message) {
            Write-Error "Message parameter required"
            exit 1
        }
        Write-Host "üéØ Task Optimization Suggestions:" -ForegroundColor Blue
        Write-Host "===================================" -ForegroundColor Blue
        $complexity = Get-TaskComplexity $Message
        switch ($complexity) {
            "complex" {
                Write-Host "üèóÔ∏è  Complex Task Detected - Use Research-Plan-Code:" -ForegroundColor Red
                Write-Host "  Phase 1: Research with Gemini CLI (free)" -ForegroundColor Green
                Write-Host "  Phase 2: Architecture with Claude Code (premium)" -ForegroundColor Yellow
                Write-Host "  Phase 3: Implementation with Aider + Local (free)" -ForegroundColor Green
                Write-Host "`nüí° This saves ~60% vs using Claude Code for everything" -ForegroundColor Cyan
            }
            "moderate" {
                Write-Host "‚ö° Moderate Task - Use Free Tools:" -ForegroundColor Yellow
                Write-Host "  Primary: Aider + Local Models" -ForegroundColor Green
                Write-Host "  Backup: Gemini CLI" -ForegroundColor Green
                Write-Host "  Avoid: Claude Code (overkill)" -ForegroundColor Red
            }
            "simple" {
                Write-Host "üöÄ Simple Task - Use Fastest Free Option:" -ForegroundColor Green
                Write-Host "  Primary: Gemini CLI" -ForegroundColor Green
                Write-Host "  Backup: Local Models" -ForegroundColor Green
                Write-Host "  Avoid: Claude Code (expensive overkill)" -ForegroundColor Red
            }
        }
    }
}

Write-Host ""